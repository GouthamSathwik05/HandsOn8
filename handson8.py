# -*- coding: utf-8 -*-
"""HandsOn8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VFjZ7Y9Ss0_vZl7A2OwWynL4UcCWQVtz
"""

def partition(arr,low,high):
  piv=arr[high]
  i=low-1
  for j in range(low,high):
    if arr[j]<piv:
      i+=1
      arr[i],arr[j]=arr[j],arr[i]
  arr[i+1],arr[high]=arr[high],arr[i+1]
  return i+1

def quickselect(arr,low,high,i):
  if low<high:
    p=partition(arr,low,high)
    if p==i:
      return arr[p]
    elif p>i:
      return quickselect(arr,low,p-1,i)
    else:
      return quickselect(arr,p+1,high,i)
  return arr[low]

def statistic(arr,i):
  return quickselect(arr,0,len(arr)-1,i)

arr=[3,6,2,7,5,1,4]
i=3
result=statistic(arr, i)
print(f"The {i}rd order statistic is: {result}")

class Stack:
  def __init__(self, size):
    self.size=size
    self.stack=[0]*size
    self.top=-1
  def is_empty(self):
    return self.top==-1
  def is_full(self):
    return self.top==self.size-1
  def push(self, item):
    if self.is_full():
      raise IndexError("Stack is full")
    self.top+=1
    self.stack[self.top]=item
  def pop(self):
    if self.is_empty():
      raise IndexError("Stack is empty")
    item=self.stack[self.top]
    self.top-=1
    return item
  def peek(self):
    if self.is_empty():
      raise IndexError("Stack is empty")
    return self.stack[self.top]

s=Stack(5)
s.push(1)
s.push(2)
print("Top element:", s.peek())
print("Popped element:", s.pop())

class Queue:
  def __init__(self, size):
    self.size = size
    self.queue=[0]*size
    self.front=0
    self.rear=-1
    self.count=0
  def is_empty(self):
    return self.count==0
  def is_full(self):
    return self.count==self.size
  def enqueue(self, item):
    if self.is_full():
      raise IndexError("Queue is full")
    self.rear=(self.rear+1)%self.size
    self.queue[self.rear]=item
    self.count+=1
  def dequeue(self):
    if self.is_empty():
      raise IndexError("Queue is empty")
    item=self.queue[self.front]
    self.front=(self.front+1)%self.size
    self.count-=1
    return item
  def peek(self):
    if self.is_empty():
      raise IndexError("Queue is empty")
    return self.queue[self.front]

queue = Queue(5)
queue.enqueue(1)
queue.enqueue(2)
print("Front element:", queue.peek())
print("Dequeued element:", queue.dequeue())

class Node:
  def __init__(self, value):
    self.value=value
    self.next=None
class SinglyLinkedList:
  def __init__(self):
    self.head = None
  def insert(self, value):
    new_node=Node(value)
    new_node.next=self.head
    self.head=new_node
  def delete(self, value):
    current=self.head
    previous=None
    while current:
      if current.value==value:
        if previous:
          previous.next=current.next
        else:
          self.head=current.next
        return
      previous=current
      current=current.next
    raise ValueError("Value not found in list")
  def search(self, value):
    current=self.head
    while current:
      if current.value==value:
        return True
      current=current.next
    return False
  def display(self):
    current=self.head
    values=[]
    while current:
      values.append(current.value)
      current=current.next
    return values

if __name__ == "__main__":
    ll=SinglyLinkedList()
    ll.insert(5)
    ll.insert(10)
    ll.insert(3)
    print("List after insertions:", ll.display())
    print("Searching for 10:", ll.search(10))
    print("Searching for 15:", ll.search(15))

    ll.delete(10)
    print("List after deletion of 10:", ll.display())
    try:
        ll.delete(15)
    except ValueError as e:
        print(e)
    print("Final list:", ll.display())